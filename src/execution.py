# src/execution.py
from src.event import FillEvent
import datetime

class ExecutionHandler:
    """
    Handles the interaction between the Order generated by the 
    Portfolio and the ultimate Fill object.
    """
    def execute_order(self, event):
        raise NotImplementedError("Should implement execute_order()")

class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order objects
    into their equivalent fill objects automatically without latency, 
    slippage or fill-ratio issues.
    """
    def __init__(self, events):
        self.events = events

    def execute_order(self, event):
        """
        Simply converts Order -> Fill
        """
        if event.type == 'ORDER':
            # Create the Fill Event
            # In a real sim, we would calculate slippage here.
            fill_event = FillEvent(
                datetime.datetime.utcnow(), 
                event.symbol, 
                'ARCA',  # Mock Exchange
                event.quantity, 
                event.direction, 
                fill_cost=None,  # We don't know the price here?
                commission=None
            )
            # wait! The standard fill event needs a price (fill_cost).
            # But the 'Order' doesn't usually carry the price (it's a Market Order).
            # In simple backtests, we usually cheat and let the Portfolio 
            # estimate the cost, OR we look up the price here.
            
            # To keep it simple for Module 2: 
            # We will pass 'None' and let the Portfolio fill in the price 
            # from the DataHandler during the update.
            # *Correction for this specific architecture:* # It's cleaner to handle Fills inside the loop where we have price access.
            # But for now, let's push the fill.
            
            self.events.put(fill_event)